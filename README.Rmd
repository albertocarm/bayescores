
---
  output: github_document
---
  


```{r setup, include=FALSE}
devtools::load_all()
```

# bayescores: Comprehensive Quantification of Clinical Benefit in Randomized Controlled Trials Using Bayesian Inference and Multi-Attribute Utility Theory

**`bayescores`** provides a comprehensive toolkit for analyzing randomized controlled trials (RCTs). This package introduces the **Bayesian Clinical Benefit Scores (BayeScores)**, a novel metric to quantify clinical benefit by accounting for both survival prolongation and cure rates.

The package includes functions to:
  
  - Simulate realistic survival data from a mixture cure model.
- Fit Bayesian Accelerated Failure Time (AFT) mixture cure models using Stan.
- Visualize model results and diagnostics.
- Calculate and visualize BayeScores to provide a holistic measure of clinical benefit.

## Installation

Install the development version of `bayescores` from GitHub:
  
  ```r
# install.packages("devtools")
devtools::install_github("albertocarm/bayescores")
```

## Full example

This example illustrates the complete workflow—from data simulation to visualization of benefit scores. Here, simulated RCTs enable clear observation of how parameter changes influence BayeScores.

### Step 1: Load the package

```{r load-library}
library(bayescores)
```

### Step 2: Simulate survival data

Simulate a 300-patient trial with long-term survival fractions of 30% (experimental) vs. 20% (control), and a median survival of 12 months in the control arm. The experimental arm gets a 25% survival boost among non-cured patients.

These parameters are intentionally set for low evidence — a toy example to show off the package’s ability not just to measure clinical benefit, but to adjust it and keep bias under control.


```{r simulate-data}

set.seed(123)

sim_data <- simulate_weibull_cure_data(
  n_patients = 300,
  cure_fraction_ctrl = 0.20,
  cure_fraction_exp = 0.30,
  max_follow_up = 60,
  weibull_shape = 1.2,
  median_survival_ctrl = 12,
  time_ratio_exp = 1.25
)

plot_km_curves(sim_data)

data(package = "bayescores")
```

### Step 3: Simulate study toxicity

Generate toxicity data for a trial with 1:1 randomization (150 control patients), baseline toxicity of 50% (any-grade), 20% severe events (G3–4), and 1.5× higher toxicity in the experimental arm. QoL outcomes assume "Significant Improvement" with "Very High" evidence.

**Quality of Life Parameters:**
  
  - `qol_scenario` (expected QoL outcome):
  - `1`: **Significant Improvement**
  - `2`: **Stabilization / Probable Benefit**
  - `3`: **No Difference / Marginal Benefit**
  - `4`: **Deterioration**
  - `5`: **Insufficient Data / Unknown**
  
  - `qol_strength` (confidence in QoL evidence):
  - `1`: **Very Low**
  - `2`: **Low**
  - `3`: **Moderate**
  - `4`: **High**
  - `5`: **Very High**
  
```{r simulate_toxicity}
toxicity_trial <- simulate_trial_data(
  n_control = 150,
  ratio_str = "1:1",
  control_g1_4_pct = 50,
  control_g3_4_pct = 20,
  tox_ratio = 1.5,
  qol_scenario = 1,
  qol_strength = 5
)
```

To analyze toxicity in *non-simulated data*, you obviously need to go to the actual toxicity table, look up the quality-of-life articles associated with that trial, and manually fill in an object similar to the one produced by the simulate_trial_data function.


Visualize toxicity with AMIT plots:
  
  **Any-grade toxicity (Grades 1–4)**
  
```{r plot_any_grade_toxicity}
create_amit_plot(
  trial_object = toxicity_trial,
  grade_type = "any_grade",
  main_title = "Example: Any-Grade Toxicity Profile",
  data_element = "toxicity",
  n_element = "N_patients"
)
```

**Severe toxicity (Grades 3+)**
  
```{r plot_severe_toxicity}
create_amit_plot(
  trial_object = toxicity_trial,
  grade_type = "severe_grade",
  main_title = "Example: Severe-Grade (G3+) Toxicity Profile",
  data_element = "toxicity",
  n_element = "N_patients"
)
```

### Step 4: Fit the Bayesian cure model

Fit the Bayesian AFT cure model (use higher `iter` in practice):
  
```{r fit_model}
bayesian_fit <- fit_bayesian_cure_model(
  sim_data,
  time_col = "time",
  event_col = "event",
  arm_col = "arm",
  iter = 2500,
  chains = 4
)
```

### Step 5: Analyze and visualize model results

The mixture cure model separates individuals into:
  
  - **Cured (long-term survivors)**: negligible event risk long-term.
- **Susceptible (uncured)**: ongoing event risk; survival prolonged but not cured.

Inspect numerical summaries and visualize posterior distributions. You can verify that the model satisfactorily recovers the time ratio and the fractions of long‑term survivors:
  
```{r numerical_summary}
print(bayesian_fit$stan_fit, pars = c("beta_cure_arm", "beta_surv_arm", "alpha"))
outcomes(bayesian_fit)
```


**Posterior distributions**
  
```{r plot-parameters, fig.cap="Figure 1: Posterior density distributions for Time Ratio, Odds Ratio of Cure, and Cure Probability Difference."}
plot_densities(bayesian_fit)
```

**Posterior predictive check**
  You can observe how the model’s predictions align satisfactorily with the Kaplan–Meier estimator:
  
```{r plot-model-fit, fig.cap="Figure 2: Posterior predictive check (model vs Kaplan-Meier data)."}
plot(bayesian_fit)
```

### Step 6: Integrate toxicity data

Toxicity is summarized by a burden‑of‑toxicity score, which weights both the severity and the category of toxicity (see technical documentation). 


```{r toxicity-integration, fig.cap="Figure 3: Distribution of burden-of-toxicity score."}
set.seed(123)

soc_weights <- c(
  "Gastrointestinal disorders" = 1.2,
  "Blood and lymphatic system disorders" = 1.6,
  "General, metabolic, and other disorders" = 1.3,
  "Dermatologic disorders" = 1.1,
  "Infections and infestations" = 1.6,
  "Respiratory, thoracic and mediastinal disorders" = 2.5)

toxicity_output <- calculate_toxicity_analysis(
  trial_data = toxicity_trial,
  n_simulations = bayesian_fit$n_draws,
  unacceptable_rel_increase = 0.5,
  k_uncertainty = 5,
  soc_weights = soc_weights
)


```


***Note on customizing toxicity weights***

The default weights for toxicity categories (e.g., "Gastrointestinal disorders" = 1.2, "Respiratory, thoracic and mediastinal disorders" = 2.5) are a sensible starting point, but they are not one-size-fits-all. The clinical impact of a side effect is highly context-dependent. For example, severe nausea might be considered more burdensome in a palliative setting than in a curative one.

We strongly encourage stakeholders—clinicians, patient representatives, and regulators—to discuss and customize these weights to reflect the specific disease context and patient population of the trial being evaluated. The `calculate_toxicity_analysis` function is designed for this flexibility via the `soc_weights` argument, allowing for a more nuanced and clinically relevant analysis.




# Understanding the Toxicity Analysis in Practice

The toxicity analysis provides a nuanced view of a drug's safety profile. Let's break down the key parameters using a practical example where the function returns these scores:

    > toxicity_output$wts_scores
      Experimental Control
    1       3.147  2.007


**1. What are the WTS (Weighted Toxicity Scores)?**

Think of the WTS as a *total harm score* for each arm of the trial. It's not just a simple count of side effects. Instead, it's a composite score where:

- *Severity matters*: High-grade toxicities (Grade 3-4) add much more to the score than low-grade ones.
- *Type matters*: Clinically relevant toxicities (e.g., blood disorders) are weighted more heavily than less critical ones (e.g., skin disorders).

Let’s say the experimental arm ended up with a harm score of 3.147, versus 2.007 for control.
(Truth be told, these numbers dance around a little — it’s a simulation — but you get the idea.)
What matters is the pattern: the experimental drug is clearly more toxic.
The real question is: how much more is too much?

---

**2. Defining "Unacceptable" (`unacceptable_rel_increase = 0.5`)**

This parameter is your *toxicity budget*. It doesn't set a fixed limit, but a relative one based on the control arm.  
A value of `0.5` means:

> "I am willing to accept a new drug that is up to 50% more toxic than the control. Anything beyond that, I consider unacceptable."

Let's apply this to our scores:

- **Your Budget** (in WTS points): ` 0.5*  2.007 = 1.0035`
- **The Observed Cost**: `3.147 - 1.0035 = 2.1435`

**Conclusion**: The observed increase in harm (**2.1435**) is greater than your budget (**1.0035**).  
Therefore, according to your own definition, the toxicity of the new drug is *unacceptable*.

This comparison is used to center the final probability distribution.

---

**3. Calibrating Uncertainty (`k_uncertainty`)**

The real world has uncertainty. The `k_uncertainty` parameter lets you define how skeptical you are of the results, which influences the *confidence* of the final output. It directly controls the width of the final probability distribution.

- A low `k` (e.g., 5) means you have high confidence in the data. You believe the observed difference is close to the true difference. This results in a narrow, sharp probability distribution, leading to a more decisive conclusion.
- A high `k` (e.g., 30) means you are more skeptical. You believe the observed difference could be due to random chance, especially with a small number of patients. This results in a wide, flat probability distribution, indicating less certainty in the outcome.

In short, `k_uncertainty` allows you to calibrate the model based on the quality and size of the trial data, ensuring the final result reflects an appropriate level of statistical confidence.


### Step 7: Quality-of-life weighting

QoL adjustments modeled using multinomial distribution:
  
```{r qol-weighting, fig.cap="Figure 4: Multinomial distribution of QoL levels."}
qol_scores <- sample_qol_scores(
  prob_vector = toxicity_trial$qol,
  n_samples = bayesian_fit$n_draws
)

plot_qol_histogram(qol_scores)
```

We have chosen this methodology because quality‑of‑life data are published very inconsistently—indeed, the data are a mess—and the approach will likely evolve over time. Therefore, you must read the paper, qualitatively interpret the results, and assess both the impact on quality of life and the strength of evidence. The outcome will be a multinomial distribution, as shown below. It is quite straightforward: to work with real data, the package includes the function generate_qol_vector(), which interactively generates a quality‑of‑life (QoL) probability vector.


### Step 8: Extract posterior samples and compute BayeScores

# From Clinical Data to a Final Score

Okay, we have the results from our Bayesian model, but how do we turn these numbers into a single, intuitive **BayeScore**?

This is where the *calibration* comes in.

---

Instead of using fixed rules, our model translates each clinical outcome into a  
**utility score** (from 0 to 100) using a flexible exponential utility function.

Think of it this way:  
the *first* improvements are the most exciting.  
Going from no benefit to *some* benefit is a huge leap.  
Further gains are still good, but the “wow factor” diminishes slightly.  

Our function captures this key principle of **diminishing marginal utility**.

---

The best part is: *you define the value judgment*.  
The shape of these utility curves is determined by setting simple **anchor points**.  
You answer the question:

> “How much is a certain clinical benefit worth on a 0–100 scale?”

For example, in our analysis, we used the following calibration:


```{r calculate-scores}

outcomes_obj <- outcomes(
  fit = bayesian_fit,
  shrinkage_method = "none"
)

efficacy_draws <- get_bayescores_draws(
  fit = bayesian_fit,
  shrinkage_method = "none"
)


efficacy_inputs <- list(
  tr_posterior_samples = efficacy_draws$tr_posterior_samples,
  cure_posterior_samples = efficacy_draws$cure_posterior_samples
)



# 1. Define the Final Calibration Settings ---
my_final_calibration <- list(
  efficacy = list(
    # Aggressive curve for Cure
    cure_utility_target = list(effect_value = 0.20, utility_value = 75),
    
    # Slower curve for TR
    tr_utility_target = list(effect_value = 1.25, utility_value = 50)
  )
)


# 2. Run the Bayescores Function on Your Data ---
# The function takes your data objects directly as inputs.
final_utilities <- get_bayescores(
  efficacy_inputs = efficacy_inputs,
  qol_scores = qol_scores,
  toxicity_scores = toxicity_output$toxicity_effect_vector,
  calibration_args = my_final_calibration
)
cat("--- Final Bayescores Summary ---\n")
print(final_utilities$component_summary)
```

### Step 9: Visualize final clinical benefit

**BayeScore donut plot**
  
  After these analyses, the tool delivers a final *clinical utility score* derived from all the weightings, representing the drug’s ultimate evaluation. This score is based on a simulation that assumed benefit but also factored in some toxicity, yet still resulted in an improvement in quality of life.

```{r plot-donut, fig.cap="Figure 5: BayeScore donut plot."}
plot_utility_donut(final_utilities, trial_name ="Simulated dataset (unshrinkaged)")
```

**Final score posterior distribution**
  
  It’s clear that estimating clinical benefit carries substantial uncertainty—studies are noisy, and sample sizes are limited. We’ve rigorously propagated every source of uncertainty throughout the analysis, so that you alone judge the credibility of the results.  

That is the power of the BayeScore: it isn’t a single point estimate but a full Bayesian distribution!  


```{r plot-score-density, fig.cap="Figure 6: Final BayeScore posterior distribution."}
plot_final_utility_density(final_utilities)
```


***Note on model overestimation and a proposed solution***

Okay, so looking at the unadjusted scores, you might be thinking:

> “Hold on... a high score for a study with 300 subjects where there's barely any increase in long-term survival seems a bit exaggerated, even assuming better QoL... what's going on here?”

And that's a great question. You should be aware of an inherent challenge in many statistical models—including mixture cure models—when applied to clinical trials with smaller sample sizes (low n). In this example, n = 300 is reasonable, but the short follow-up makes it difficult to accurately model the plateau of the survival curve, as shown in the Kaplan–Meier plot. Such limitations can have a significant impact on the estimation of bayescores.

This often leads to a phenomenon known as the *“winner’s curse”*: if a trial happens to show a positive result, the magnitude of the observed effect is likely an overestimation of the true effect.

# A solution: empirical bayesian shrinkage

To address this, we can apply an empirical shrinkage correction. This method uses data from thousands of previous clinical trials to create a more realistic “prior” expectation of treatment effects, pulling our potentially exaggerated results towards a more plausible value.

This package implements two such data-driven priors:

- **"zwet"**: a general prior based on 23 551 trials from all fields of medicine.

  van Zwet E, Schwab S, Senn S. (2021). *The statistical properties of RCTs and a proposal for shrinkage*. Statistics in Medicine. DOI: 10.1002/sim.9173.

- **"sherry"**: a more specific prior based on 415 phase III oncology trials, so an option for cancer-related studies.

  Sherry AD, Msaouel P, et al. (2024). *An Evidence-Based Prior for Estimating the Treatment Effect of Phase III Randomized Trials in Oncology*. JCO Precision Oncology. DOI: 10.1200/PO.24.00363.

Let's see how applying these corrections affects our final utility score.

```{r apply_shrinkage}

# apply shrinkage with zwet prior
shrunk_zwet <- outcomes(
  fit                 = bayesian_fit,
  shrinkage_method = "zwet"
)

efficacy_draws_zwet <- get_bayescores_draws(
  fit = bayesian_fit, 
  shrinkage_method = "zwet"
)

efficacy_inputs_zwet <- list(
  tr_posterior_samples = efficacy_draws_zwet$tr_posterior_samples,
  cure_posterior_samples = efficacy_draws_zwet$cure_posterior_samples
)

# compute corrected utilities for zwet
utilities_zwet <- get_bayescores(
  efficacy_inputs = efficacy_inputs_zwet,
  qol_scores      = qol_scores,
  toxicity_scores = toxicity_output$toxicity_effect_vector,
  calibration_args = my_final_calibration
)


# apply shrinkage with sherry prior
shrunk_sherry <- outcomes(
  fit                 = bayesian_fit,
  shrinkage_method = "sherry"
)

efficacy_draws_sherry <- get_bayescores_draws(
  fit = bayesian_fit, 
  shrinkage_method = "sherry"
)

efficacy_inputs_sherry <- list(
  tr_posterior_samples = efficacy_draws_sherry$tr_posterior_samples,
  cure_posterior_samples = efficacy_draws_sherry$cure_posterior_samples
)


# compute corrected utilities for sherry
utilities_sherry <- get_bayescores(
  efficacy_inputs = efficacy_inputs_sherry,
  qol_scores      = qol_scores,
  toxicity_scores = toxicity_output$toxicity_effect_vector,
  calibration_args = my_final_calibration
)


# compare unshrunk vs. zwet vs. sherry
comparison <- rbind(
  cbind(prior = "unshrunk", final_utilities$component_summary[6,2 , drop = FALSE]),
  cbind(prior = "zwet",     utilities_zwet$component_summary[6,2 , drop = FALSE]),
  cbind(prior = "sherry",   utilities_sherry$component_summary[6,2 , drop = FALSE])
)
rownames(comparison) <- NULL

print(comparison)

# plot utility donuts for each prior
plot_utility_donut(utilities_zwet, trial_name ="Zwet's shrinkage")
plot_utility_donut(utilities_sherry, trial_name ="sherry's shrinkage")


```

You can see how each empirical prior pulls the original estimates toward more conservative, data-driven values. This shrinkage step provides a robust sensitivity analysis, helping to understand how potential overestimation might impact the overall utility of a treatment and leading to more reliable conclusions for decision-making.


***Complex mixture case (immunotherapy-like)***

- Mixed population typical of immunotherapy RCTs.  
- Experimental arm increases the long-term survivor fraction (cure fraction).  
- Among non-cured (refractory) patients, there is modest harm (TR < 1).  
- QoL and Toxicity are **not** simulated here; we assume prior/previous settings.  
 

```{r complex-mixture-case}

set.seed(123)

# 1) Simulate an archetypal mixed cohort
sim_data <- simulate_weibull_cure_data(
  n_patients          = 300,
  cure_fraction_ctrl  = 0.20,
  cure_fraction_exp   = 0.35,
  max_follow_up       = 60,
  weibull_shape       = 1.2,
  median_survival_ctrl= 12,
  time_ratio_exp      = 0.75
)

# 2) Fit Bayesian mixture cure model
bayesian_fit <- fit_bayesian_cure_model(
  sim_data,
  time_col  = "time",
  event_col = "event",
  arm_col   = "arm",
  iter      = 2500,
  chains    = 4
)

# 3) Inspect model outcomes
mod_out <- outcomes(bayesian_fit)
print(mod_out)

# Plot model fit
plot(bayesian_fit)

# 4) Obtain MCMC draws for efficacy components
outcomes_obj <- outcomes(
  fit              = bayesian_fit,
  shrinkage_method = "none"
)
efficacy_draws <- get_bayescores_draws(
  fit              = bayesian_fit,
  shrinkage_method = "none"
)

efficacy_inputs <- list(
  tr_posterior_samples   = efficacy_draws$tr_posterior_samples,
  cure_posterior_samples = efficacy_draws$cure_posterior_samples
)


```

*Disutility penalty*

Here we introduce a disutility penalty for scenarios where the majority experiences modest harm (TR < 1), even when a minority achieves substantial long-term benefit. This penalty reduces the overall utility in proportion to the magnitude of short-term harm, ensuring that large gains for a few do not overshadow consistent detriment for many.

  
```{r disutilities}
# 5) Final calibration for utilities & disutilities
my_final_calibration <- list(
  efficacy = list(
    cure_utility_target = list(effect_value = 0.20, utility_value = 75),
    tr_utility_target   = list(effect_value = 1.25, utility_value = 50),
    tr_disutility_target= list(effect_value = 0.85, utility_value = 20)
  )
)

# 6) Compute final BayeScores
final_utilities <- get_bayescores(
  efficacy_inputs = efficacy_inputs,
  qol_scores = qol_scores,
  toxicity_scores = toxicity_output$toxicity_effect_vector,
  calibration_args = my_final_calibration
)

cat("--- Final BayeScores Summary ---\n")
plot_utility_donut(final_utilities, trial_name ="Simulated dataset (unshrinkaged)")

```



***Sensitivity Analysis Dashboard***

To clarify how parameter choices affect the final Bayescore and to support model calibration, we provide a sensitivity-analysis dashboard. It produces an 8-panel plot showing how the final utility responds to changes in the core parameters—Time Ratio (TR), Cure Rate, Quality of Life (QoL), and Toxicity—offering a global view of model behavior across scenarios.



```{r sensitivity-dashboard, fig.width=10, fig.height=12, message=FALSE, warning=FALSE}
# First, we define any custom calibration arguments.
# We can use an empty list to accept the model's defaults.
calibration_settings <- list(
  efficacy = list(
    cure_utility_target = list(effect_value = 0.20, utility_value = 75),
    tr_utility_target = list(effect_value = 1.25, utility_value = 50)
  )
)


# Now, we generate the complete 8-panel dashboard
# The function will print its progress as it generates the data.
dashboard <- generate_sensitivity_dashboard(
  calibration_args = calibration_settings
)

# Finally, display the plot
print(dashboard)
```

***Reconstructing Survival Data from Published Plots***

A perceived limitation of bayescores is its requirement for Individual Patient Data (IPD), in contrast to other value frameworks that can use aggregated data reported in the literature. To mitigate this limitation, this section demonstrates a workflow to reconstruct IPD from a published Kaplan-Meier curve image. The goal is to transform a static plot into a usable dataset, enabling full re-analysis and custom visualization.

For this demonstration, we used Figure 2 from Hortobagyi, G. N., et al. "Updated results from MONALEESA-2..." Annals of Oncology 29.7 (2018). This is an Open Access article under the CC-BY-NC license.


```{r monaleesa-2, fig.width=10, fig.height=12, message=FALSE, warning=FALSE}
image_path <- system.file("extdata", "mona2.png", package = "bayescores")
# install.packages("magick")

library(magick)
trial_plot <- image_read(image_path)
print(trial_plot)

```

The workflow consists of three main steps:

*Digitization* 
We first extract the curve coordinates from the published image. This can be done with R packages like SurvdigitizeR. If you encounter issues, web-based tools like WebPlotDigitizer (available at https://automeris.io/) are excellent alternatives. The number-at-risk table that accompanies the plot is transcribed manually.

```{r digitise, message=FALSE, warning=FALSE}
library(ggplot2)
library(dplyr)
library(survival)
library(survminer)
library(SurvdigitizeR)

plot_km_monaleesa <- survival_digitize(img_path = "C:/Users/Usuario/Documents/aft cure model/digitalizar/mona2.png",
                                       num_curves = 2,
                                       x_start = 0,
                                       x_end = 34,
                                       x_increment = 2,
                                       y_start = 0,
                                       y_end = 100,
                                       y_increment = 20,
                                       y_text_vertical =  T)

```
*Reconstruction*
This is the core of the process. We use a programmed version of the algorithm described by Guyot et al. (2012) to reverse-engineer the individual event and censoring times from the aggregated digitized data. This step effectively creates a full patient-level dataset.
```{r ipd reconstruction, message=FALSE, warning=FALSE}

# The IPD reconstruction algorithm requires two inputs: the digitized curve
# coordinates and the number of patients at risk at specific time points.
# This data frame is a manual transcription of the "No. at risk" table
# from the published plot for both treatment arms.

nrisk_tbl_all <- rbind(
  # Data for the first curve (treatment arm)
  data.frame(
    time_tick = c(0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34),
    nrisk     = c(334, 294, 277, 257, 240, 227, 207, 196, 188, 176, 164, 132, 97, 46, 17, 11, 1, 0),
    curve     = 1L  # Curve 1: Ribociclib + Letrozole arm
  ),
  # Data for the second curve (control arm)
  data.frame(
    time_tick = c(0,  2,  4,  6,  8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34),
    nrisk     = c(334, 279, 265, 239, 219, 196, 179, 156, 138, 124, 110, 93, 63, 34, 10, 7, 2, 0),
    curve     = 2L  # Curve 2: Placebo + Letrozole arm
  )
)

# Now we run the core reconstruction algorithm. This is done separately for each
# treatment arm because the survival and censoring patterns are unique to each one.

# Reconstruct IPD for the first curve (Ribociclib arm)
res1 <- reconstruct_ipd(
  plot_km   = subset(plot_km_monaleesa, curve == 1), # Use digitized data for curve 1
  nrisk_tbl = subset(nrisk_tbl_all,   curve == 1)  # Use risk numbers for curve 1
)

# Reconstruct IPD for the second curve (Placebo arm)
res2 <- reconstruct_ipd(
  plot_km   = subset(plot_km_monaleesa, curve == 2), # Use digitized data for curve 2
  nrisk_tbl = subset(nrisk_tbl_all,   curve == 2)  # Use risk numbers for curve 2
)


# The final step is to merge the results from both reconstructions into a single,
# tidy dataset that is ready for analysis and plotting.

res <- list(
  # Combine the individual patient data from both arms
  ipd   = bind_rows(
    res1$ipd %>% mutate(curve = 1L), # IPD from curve 1
    res2$ipd %>% mutate(curve = 2L)  # IPD from curve 2
  ) %>%
    # Convert the numeric 'curve' column into a factor with meaningful labels.
    # This is essential for correct labeling in plots and models.
    mutate(curve = factor(curve,
                          labels = c("Ribociclib + letrozol",
                                     "Placebo + letrozol"))),

  # 'drops' is likely a secondary output from the reconstruction function,
  # containing details about the survival probability drops. We combine it here as well.
  drops = bind_rows(
    res1$drops %>% mutate(curve = 1L),
    res2$drops %>% mutate(curve = 2L)
  )
)
```

*Re-analysis and Visualization*
Once the IPD is generated, it can be used directly within bayescores or for any other analysis. This allows users to verify the original study's results with survfit and coxph or create fully customized, publication-quality plots with ggsurvplot, providing complete analytical and visual control.

```{r ipd plot}

fit <- survfit(Surv(time, status) ~ curve, data = res$ipd)

ggsurvplot(
  fit,
  data = res$ipd,
  palette = c("#E69F00", "#0072B2"), # Swapped colors to match new factor levels
  conf.int = FALSE,
  censor = FALSE,
  xlab = "Time (months)",
  ylab = "Probability of PFS (%)",
  fun = "pct",
  break.time.by = 2,
  xlim = c(0, 34),
  legend.title = "",
  legend.labs = c("Placebo\n+ Letrozole", "Ribociclib\n+ Letrozole"), 
  legend = c(0.75, 0.85),
  risk.table = FALSE
)

```



## Why bayescores? a more meaningful approach

- **Clinically interpretable**: time ratios are easier to explain to clinicians and patients than hazard ratios, and mixture cure models separate short-term survival effects from the long-term survivor fraction. This resolves the problem of “double counting” benefit—first via the HR and again through a separate long-term bonus—ensuring both metrics remain independent.
- **Accounts for cure scenarios**: explicitly models cure rates and long-term survivor fractions, making it particularly relevant for immunotherapy and other treatments with a survival plateau.  
- **Embraces uncertainty**: the Bayesian framework propagates uncertainty from all model stages, displaying full posterior distributions rather than collapsing results into single point estimates.  
- **No thresholds**: uses continuous parameters and proportional weights rather than fixed cut-offs, producing smooth, gradual changes in the score. This avoids all-or-nothing jumps and makes the valuation process transparent, reproducible, and customizable to stakeholder priorities.  
- **Integrates multiple dimensions**: combines efficacy, toxicity, and quality of life within a unified decision-analytic framework (MAUT), with hierarchical aggregation that mirrors clinical reasoning: efficacy first, then QoL, then toxicity.  
- **Customizable toxicity weighting**: Weighted Toxicity Scores can incorporate grade-specific and type-specific penalties, reflecting the clinical relevance of different adverse events and aligning with disease-specific “toxicity budgets.”  
- **Accessible implementation**: provided as an open-source R package (`bayescores`) with full workflow examples on GitHub, including KM curve digitization and IPD reconstruction tools, plus a web interface for no-code calculation and visualization.  

## Citation

```r
citation("bayescores")
```
